		Инструкция по пользованию:
	1. Ввод ключей:
1.1. При вызове файла solve.exe необходимо указать ключи, по которым будет работать программа.
		 Поддерживаемые ключи: '--forward', '--reverse', '--file'.
1.2. При вызове файла, среди ключей должен быть только один из '--forward' или '--reverse'. 
		 Наличие ключа '--file' опционально.
1.3. При использовании ключа '--file' программа считает выражение из файла под названием SolveFile 
     в той же директории, что и исходные файлы.

	2. Задание выражения:
2.1. При задании выражения рекомендуется завершать его знаком '='.
     В противном случае (при вводе через входной поток) необходимо ввести символ завершения ввода
     с помощью сочетания клавиш (CTRL + Z) (для OC Windows) (возможно придётся ввести дважды).
2.2. При задании выражения можно пропускать пробелы между операторами и числами или двумя операторами.
2.3. При задании выражения, если до или после символов '(' и ')' соответственно не будут находится 
     операторы, программа воспримет это как опущенный символ '*'.

		
		Отчёт:
	Задача:
	Сделать программу, которая будет считывать и обрабатывать введёное математическое выражение 
	и выводить его значение.

	Описание:
	Моя программа считывает и обрабатывает введённые ключи и вызывает соответствующие функции.
	Обрабатывает выражения с помощью алгоритма, использующего методы и объекты, схожие со стеками, однако
	несколько отличающиеся от них. 
	В программе используются только функции созданные мной (за исключением нескольких базовых).
	Также прилагается Makefile, поддерживающий функции make, clean и distclean.

	Тесты:
	Все тесты из примеров, а также мой собственные тесты прошли проверку успешно.

	Подробное описание алгоритма:
	Программа считывает ключи и обрабатывает их соответствующей функцией. Далее в зависимости от введённых
	ключей или выдаёт ошибку или запускает одну из двух основных функций. 
	
	Сами функции посимвольно обрабатывают введённые далее данные и разделяет их на 2 массива: 
	массив чисел и массив операторов (только в случае прямой записи, т.к. в обратной записи не имеет смысла 
	хранить в памяти операторы: они записываются в том порядке, в котором и должны выполняться).

	Далее, в случае прямой записи, алгоритм обрабатывает эти массивы по тому же принципу, по которому 
	обрабатываются стеки (зависимость действий от приоритета операторов).